---
description: ts 装饰器
date: 2024-04-16
tag:
  - typescript
sticky: 1
---

# 装饰器

*装饰器*是一种特殊类型的声明，它能够被附加
到[类声明](https://www.tslang.cn/docs/handbook/decorators.html#class-decorators)，[方法](https://www.tslang.cn/docs/handbook/decorators.html#method-decorators)，
[访问符](https://www.tslang.cn/docs/handbook/decorators.html#accessor-decorators)，[属性](https://www.tslang.cn/docs/handbook/decorators.html#property-decorators)或[参数](https://www.tslang.cn/docs/handbook/decorators.html#parameter-decorators)上
。 装饰器使用 `@expression`这种形式，`expression`求值后必须为一个函数，它会在运
行时被调用，被装饰的声明信息做为参数传入。

例如，有一个`@sealed`装饰器，我们会这样定义`sealed`函数：

```ts
function sealed(target) {
  // do something with "target" ...
}
```

动态注入

```sandpack
function Sealed(constructor: Function) {
  Object.seal(constructor);
}
function InjectUser() {
  return function (constructor: Function) {
    constructor.prototype.user = "user";
  }
}
// 元数据
function CheckKey(
):PropertyDecorator{
  return function (target, key) {
   //  const existKey = Reflect.getMetadata("check", target.constructor) ?? []
   //  existKey.push(key);
  //   Reflect.defineMetadata("check", existKey, target.constructor)
  }
}

@Sealed
@InjectUser()
class Greeter {
  @CheckKey()
  greeting!: string;
}
const greeter =new Greeter();
console.log((greeter as any).user);

```
