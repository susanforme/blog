# 设计模式

### 反射(Reflection)

reflect-metadata

TypeScript 中的 reflect-metadata 包确实实现了一部分“反射（Reflection）”能力，用
于在运行时读取或写入类型相关的元数据，这在 JavaScript 中是原生不具备的。

🧠 什么是“反射”？反射是指程序在运行时可以“自我检查”和“自我修改”的能力，常见于
Java、C# 等语言。

在 JavaScript/TypeScript 语境中，反射指的是：在运行时读取类、方法、参数、属性的
类型信息动态获取元数据，甚至动态调用

### 控制反转（IoC）

### 依赖注入（DI）

### 面向切面编程（AOP）

在没有 AOP 的情况下，功能模块间的横切关注点（如日志记录、事务管理）会反复出现在
代码的不同地方。每当业务逻辑改变时，我们可能需要修改多个位置的代码，导致代码难以
维护。AOP 通过将这些横切关注点提取到切面中，避免了代码重复，简化了维护和扩展。

#### AOP 的核心概念

- **切面（Aspect）**：切面是 AOP 的核心，代表了横切关注点的模块化，包含了跨越多
  个功能模块的代码逻辑。例如，日志切面、事务切面、权限验证切面等。

- 通知（Advice）

  ：通知是 AOP 中定义的操作，描述了“什么时候”以及“如何”去执行切面代码。常见的通
  知类型包括：

  - **前置通知（Before）**：在方法执行之前执行某些操作。
  - **后置通知（After）**：在方法执行之后执行某些操作。
  - **环绕通知（Around）**：在方法执行之前和之后都执行操作，甚至可以决定是否执行
    目标方法。

例如 axios 的拦截器

```ts
import axios from 'axios';

const instance = axios.create({
  baseURL: 'https://api.example.com',
});
instance.interceptors.request.use((config) => {
  // 在发送请求之前做些什么
  return config;
});
instance.interceptors.response.use((response) => {
  // 对响应数据做些什么
  return response;
});
```

### 面向对象编程（OOP）

### 函数式编程（FP）

### 策略模式

```ts
export function createStorageQueue(
  key: string,
  maxLength: number,
  storage: Storage = localStorage,
) {
  function getQueue(): string[] {
    const data = storage.getItem(key);
    if (!data) return [];
    try {
      return JSON.parse(data);
    } catch {
      return [];
    }
  }

  function saveQueue(queue: string[]) {
    storage.setItem(key, JSON.stringify(queue));
  }

  return {
    enqueue(item: string) {
      let queue = getQueue();
      queue.push(item);
      queue = [...new Set(queue)];
      while (queue.length > maxLength) {
        queue.shift();
      }
      saveQueue(queue);
    },
    getQueue() {
      return getQueue();
    },
    clear() {
      storage.removeItem(key);
    },
  };
}
```

```typescript
@Injectable()
export class UserService {
  // 省略业务逻辑
}

@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Get()
  getAll() {
    return this.userService.findAll();
  }
}
```

上例中，`UserController` 通过构造函数注入 `UserService`，对象的创建和依赖关系由
NestDI 容器自动处理，这就是**依赖注入**的体现。Nest 中的模块（`@Module`）、服务
（`@Injectable`）等装饰器都使用元数据来标记依赖关系，框架启动时扫描这些信息并自
动实例化所需对象，从而实现控制反转。

## 面向切面编程（AOP）的基本思想及实现思路

面向切面编程（AOP）是一种将通用逻辑（如日志、权限、异常处理）与业务逻辑分离的编
程范式。其核心思想是在程序运行的执行链路上“横切”地加入额外逻辑，而无需在业务代码
中显式添加。例如，在请求调用链前后插入日志或权限校验，就属于 AOP 手段。这样可以
让业务代码保持纯粹，将横切关注点提取到可复用的切面中。

NestJS 内置了多种 AOP 机制：传统的 **中间件（Middleware）**、请求 **守卫
（Guard）**、参数验证/转换 **管道（Pipe）**、方法前后处理 **拦截器
（Interceptor）** 以及异常 **过滤器（Exception Filter）**。通过这些机制，开发者
可以在控制器方法执行前后透明地添加各种通用逻辑。例如，使用守卫判断请求权限、使用
拦截器统一格式化响应、使用异常过滤器捕获并处理抛出的错误等。这些机制都是 Nest 对
AOP 思想的具体实现，使得横向关注点可以灵活地应用于全局或单个路由。
