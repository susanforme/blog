---
title: node内存泄漏分析及解决
description: 本文分析了Node.js中常见的内存泄漏问题及其解决方案，帮助开发者优化应用性能。
pubDate: 2026-02-05
---

## 前情提要

最近在发版时遇到了一次内存泄漏问题，导致应用在运行一段时间后内存占用稳步提升，如下图所示：

![内存泄漏](./img/oom.png)

## chrome开发者工具

由于主要分析工具是chrome开发者工具，本文先简单介绍.

### 对象大小

将内存视为包含基元类型（例如数字和字符串）和对象（关联数组）的图。它在视觉上可以表示为包含多个相互关联的点的图表，如下所示：

![对象](./img/object.png)

对象可以通过以下两种方式占用内存：

- 直接由对象本身进行调用。
- 隐式地保留对其他对象的引用，从而防止这些对象被垃圾回收器自动处置。

在 DevTools 中使用堆性能分析器,主要关注Shallow Size和Retained Size。

![shallow](./img/shallow-retained-size.png)

### 浅层大小

这是对象本身占用的内存大小。

典型的 JavaScript 对象会预留一些内存来存储其说明和立即值。通常，只有数组和字符串可以具有较大的浅层大小。不过，字符串和外部数组的主要存储空间通常位于渲染程序内存中，并且只在 JavaScript 堆上公开一个小型封装容器对象。

渲染程序内存是指用于渲染受检页面的进程的所有内存：原生内存 + 页面的 JS 堆内存 + 由页面启动的所有专用工作器的 JS 堆内存。不过，即使是小对象，也可以通过阻止自动垃圾回收进程处置其他对象，间接占用大量内存。

### 保留的大小

这是在删除对象本身及其无法从 **GC 根**访问的依赖对象后释放的内存大小。

**GC 根**由在从原生代码引用 V8 之外的 JavaScript 对象时创建的*句柄*（本地或全局）组成。您可以在堆快照的 **GC 根** > **Handle 作用域**和 **GC 根** > **全局句柄**下找到所有此类句柄。

存在许多内部 GC 根，其中大多数对用户而言并不重要。从浏览器的角度来看，根有以下几种：

- 窗口全局对象（在每个 iframe 中）。堆快照中有一个距离字段，该字段是从窗口到最短保留路径上的属性引用数量。
- 文档 DOM 树，由遍历文档可访问的所有原生 DOM 节点组成。其中有些可能没有 JS 封装容器，但如果有，则封装容器会在文档有效期间保持有效。
- 有时，调试程序上下文和开发者工具控制台可能会保留对象（例如在控制台评估后）。创建堆快照，并确保控制台清晰且调试器中没有有效断点。

内存图从根开始，该根可以是浏览器的 `window` 对象，也可以是 Node.js 模块的 `Global` 对象。您无法控制此根对象的 GC 方式。

![gc-root](./img/root-object-t-controlle.png)

从根无法访问的任何内容都会被 GC。（可达性分析）

#### 支配者

**支配者对象**由树状结构组成，因为每个对象有且仅有一个直接支配者。一个对象的支配者可能并不包含对其所支配对象的直接引用；也就是说，支配者树并不是原图的生成树。

**在下图（逻辑）中：**

- 节点 1 支配节点 2
- 节点 2 支配节点 3、4 和 6
- 节点 3 支配节点 5
- 节点 5 支配节点 8
- 节点 6 支配节点 7

![支配树](./img/dominator-tree-structure.png)

在以下示例中，节点 **#7**、**#3** 以及 **GC** 都是节点 **#10** 的**支配者**，因为它们存在于从根节点 (GC) 到节点 #10 的每一条路径上。特别地，**#7** 是节点 #10 的**直接支配者 (Immediate Dominator)**，因为它是从 GC 到 #10 的路径上距离 #10 最近的支配者。

![支配者示例](./img/animated-dominator-illust.gif)
